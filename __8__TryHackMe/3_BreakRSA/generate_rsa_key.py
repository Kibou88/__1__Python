import math


p = 30989413979221186440875537962143588279079180657276785773483163084840787431751925008409382782024837335054414229548213487269055726656919580388980384353939415484564294377142773553463724248812140196477077493185374579859773369113593661078143295090153526634169495633688691753691720088511452131593712380121967802013042678209312444897975134224456911144218687330712554564836016616829044029963400114373142702236623994027926718855592051277298418373056707389464234977873660836337340136755093657804153998347162906059312569124331219753644648657722107663012261197728061352359157767204739644300066112274629356310784052940617408518123
q = 30989413979221186440875537962143588279079180657276785773483163084840787431751925008409382782024837335054414229548213487269055726656919580388980384353939415484564294377142773553463724248812140196477077493185374579859773369113593661078143295090153526634169495633688691753691720088511452131593712380121967802013042678209312444897975134224456911144218687330712554564836016616829044029963400114373142702236623994027926718855592051277298418373056707389464234977873660836337340136755093657804153998347162906059312569124331219753644648657722107663012261197728061352359157767204739644300066112274629356310784052940617408516621
n = 960343778775549488806716229688022562692463185460664314559819511657255292180827209174624059690060629715513180527734160798185034958883650709727032190772084959116259664047922715427522089353727952666824433207585440395813418471678775572995422248008108462980790558476993362919639516120538362516927622315187274971734081435230079153205750751020642956757117030852053008146976560531583447003355135460359928857010196241497604249151374353653491684214813678136396641706949128453526566651123162138806898116027920918258136713427376775618725136451984896300788465604914741872970173868541940675400325006679662030787570986695243903017923121105483935334289783830664260722704673471688470355268898058414366742781725580377180144541978809005281731232604162936015554289274471523038666760994260315829982230640668811250447030003462317740603204577123985618718687833015332554488836087898084147236609893032121172292368637672349405254772581742883431648376052937332995630141793928654990078967475194724151821689117026010445305375748604757116271353498403318409547515058838447618537811182917198454172161072247021099572638700461507432831248944781465511414308770376182766366160748136532693805002316728842876519091399408672222673058844554058431161474308624683491225222383
e = 65537


def euclide_etendu(a, b):
    """
    Algorithme d'Euclide étendu pour calculer l'inverse modulaire
    Retourne (pgcd, x, y) tel que a*x + b*y = pgcd(a, b)
    """
    if b == 0:
        return a, 1, 0

    # Variables pour l'algorithme
    x0, x1 = 1, 0
    y0, y1 = 0, 1

    while b != 0:
        q = a // b  # Division entière
        r = a % b  # Reste

        # Mise à jour des variables
        a, b = b, r
        x0, x1 = x1, x0 - q * x1
        y0, y1 = y1, y0 - q * y1

    return a, x0, y0


def inverse_modulaire(e, phi_n):
    """
    Calcule l'inverse modulaire de e modulo phi_n
    """
    pgcd, x, y = euclide_etendu(e, phi_n)

    if pgcd != 1:
        raise ValueError(f"e et φ(n) ne sont pas premiers entre eux (pgcd = {pgcd})")

    # Si x est négatif, on ajoute phi_n pour avoir un résultat positif
    if x < 0:
        x += phi_n

    return x

phi_n = (p-1)*(q-1) # Identique à phi_n = n - p - q + 1
print(phi_n)

pgcd, x, y = euclide_etendu(e, phi_n)

if pgcd != 1:
    raise ValueError("e et φ(n) ne sont pas premiers entre eux!")

d = inverse_modulaire(e, phi_n)

# Étape 5 : Vérification
verification = (e * d) % phi_n
print(f"Vérification: (e × d) mod φ(n) = ({e} × {d}) mod {phi_n} = {verification}")

if verification != 1:
    raise ValueError("Erreur dans le calcul de d!")

print(f"\n✅ Clé privée générée avec succès!")
print(f"Clé publique: (e={e}, n={n})")
print(f"Clé privée: (d={d}, n={n})")